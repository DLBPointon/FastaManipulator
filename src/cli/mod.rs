use clap::builder::Str;
use clap::{Parser, Subcommand};

const SPLIT_OPTIONS: [&str; 5] = ["pep", "cds", "cdna", "rna", "other"];

// CLI for Fasta Processing
#[derive(Parser)]
#[command(version="v1.0.0", about, long_about = None)]
pub struct Cli {
    // command is optional (TODO: Make this not optional)
    // Reference: https://docs.rs/clap/latest/clap/_derive/_tutorial/chapter_2/index.html#defaults
    #[command(subcommand)]
    pub command: Option<Commands>,
}

// Reference: https://docs.rs/clap/latest/clap/_derive/_tutorial/chapter_2/index.html
#[derive(Subcommand)]
pub enum Commands {
    YamlValidator {
        // Path to the TreeVal yaml file generated by the user
        #[arg(short, long)]
        yaml: String,

        // Print explainers as to why validation fails, if it does fail
        #[arg(short = 'v', long)]
        verbose: bool,

        // Output the log to file
        #[arg(short = 'o', long, default_value_t=String::from("./"))]
        output: String,
    },

    SplitByCount {
        // A path to a valid fasta file.
        #[arg(short = 'f', long)]
        fasta_file: String,

        // The output directory that files will be placed in | outfile will be formatted like {input_file_prefix}_f{file_count}_c{requested_chunk_count}-a{actual_chunk_count}.fa
        #[arg(short = 'o', long, default_value_t = String::from("./"))]
        output_directory: String,

        // The data type of the input data
        #[arg(short = 'd', value_parser = clap::builder::PossibleValuesParser::new(SPLIT_OPTIONS))]
        data_type: String,

        // Do we need to sanitise the headers of the input fasta
        #[arg(short = 's', value_parser = clap::value_parser!(bool))]
        sanitise: bool,

        // How many sequences per file
        #[arg(short = 'c', value_parser = clap::value_parser!(u16))]
        count: u16,
    },

    SplitBySize {
        // A path to a valid fasta file.
        #[arg(short = 'f', long)]
        fasta_file: String,

        // Size in MB that a fasta file is to be chunked into
        #[arg(short = 's', long = "mem-size")]
        mem_size: u16,

        // The output directory that files will be placed in | outfile will be formatted like {input_file_prefix}_f{file_count}_c{requested_chunk_count}-a{actual_chunk_count}.fa
        #[arg(short = 'o', long, default_value_t = String::from("./"))]
        output_directory: String,
    },

    GenesetCSVS {
        // The path to the top level directory of your geneset directory.
        #[arg(short = 'd')]
        geneset_dir: String,

        // Specify the clade folder to refresh
        #[arg(short = 'c', default_value_t = String::from("ALL"))]
        specifiy_clade: String,
    },

    MapHeaders {
        // A path to a valid fasta file.
        #[arg(short = 'f', long)]
        fasta_file: String,

        // The output directory which will contain the mapped-heads.txt as well as the *mapped.fasta
        #[arg(short = 'o', long, default_value_t = String::from("./"))]
        output_directory: String,

        #[arg(short = 'r', default_value_t = String::from("FMMH"))]
        replace_with: String,
    },

    ReMapHeaders {
        // A path to a valid fasta file.
        #[arg(short = 'f', long)]
        fasta_file: String,

        // The output directory which will contain the mapped-heads.txt as well as the *mapped.fasta
        #[arg(short = 'o', long, default_value_t = String::from("./new"))]
        output_directory: String,

        // "The original mapped header field, a TSV of old-header, new-header
        #[arg(short = 'm', default_value_t = String::from("FMMH"))]
        map_file: String,
    },

    #[command(version, about="Profile an input fasta file and return various statistics", long_about = None)]
    Profile {
        // A path to a valid fasta file.
        #[arg(short = 'f', long)]
        fasta_file: String,

        // The input fasta file for profiling
        #[arg(short = 'o', long, default_value_t = String::from("FasMan-out"))]
        output_dir: String,
    },

    Curate {
        // The input fasta file for re-organising
        #[arg(short = 'f', long)]
        fasta: String,

        // The TPF file used to re-organise the input fasta
        #[arg(short = 't', long)]
        tpf: String,

        // Size sort the output or leave as order in AGP
        #[arg(short = 's')]
        sort: bool,

        #[arg(short = 'o', default_value_t = String::from("new.fasta"))]
        output: String,

        // Length that the N (gap) string should be.
        #[arg(short, long, default_value_t = 200)]
        n_length: usize,
    },

    Subset {
        // A path to a valid fasta file for profiling.
        #[arg(short = 'f', long)]
        fasta_file: String,

        // Random subset of input file. Default skims the first X given percent
        #[arg(short = 'r', long)]
        random: bool,

        // Percentage of the original file entries that should be retained
        #[arg(short = 'p', long, default_value_t = 50)]
        percent: u16,
    },

    FilterFasta {
        // A fasta file for processing.
        #[arg(short = 'f', long)]
        fasta: String,

        // The outfile naming
        #[arg(short = 'o', default_value_t = String::from("FilteredFasta.fa"))]
        output: String,

        #[arg(short = 'l', long = "filter_list")]
        filter_list: String,
    },

    Mergehaps {
        // The input fasta file for re-organising
        #[arg(short = 'p', long)]
        fasta_1: String,

        // The second input fasta file
        #[arg(short = 's', long)]
        fasta_2: String,

        // TA '/' separated list with an item per file, these are the namings of the new scaffolds in the merged output
        #[arg(short = 's', long, default_value_t = String::from("PRI/HAP"))]
        naming: String,

        // Output file prefix
        #[arg(short = 'o', default_value_t = String::from("merged"))]
        output: String,
    },
}
