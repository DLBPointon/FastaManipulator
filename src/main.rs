#![allow(non_snake_case)]

use clap::{command, Arg, Command};
use colored::Colorize;
use std::env;
use std::io::Error;

mod yaml_validator;
use crate::yaml_validator::yaml_validator_mod::validate_yaml;

mod map_headers;
use crate::map_headers::mapping_headers::map_fasta_head;

mod remap_head;
use crate::remap_head::remapping_headers::remapping_head;

mod split_by_size;
use crate::split_by_size::split_by_size::split_file_by_size;

mod split_by_count;
use crate::split_by_count::split_by_count::split_file_by_count;

fn main() -> Result<(), Error> {
    let match_result = command!()
    .about("A program for fasta manipulation and yaml validation ~ Used in TreeVal project")
    .subcommand(
        Command::new("validateyaml")
            .about("Subcommand for validating the users TreeVal yaml file")
            .arg(
                Arg::new("yaml")
                    .required(true)
                    .help("Path to the TreeVal yaml file generated by the user")
            )
            .arg(
                Arg::new("verbose")
                    .short('v')
                    .value_parser(clap::value_parser!(bool))
                    .default_value("false")
                    .required(false)
                    .help("Print explainers as to why validation fails, if it does fail")
            )
            .arg(
                Arg::new("output")
                    .short('o')
                    .aliases(["out"])
                    .required(false)
                    .default_value("./")
                    .help("Output the log to file")
            )
    )
    .subcommand(
        Command::new("splitbycount")
            .about("Subcommand for splitting fasta files by number of sequence-header pairs, e.g., 100 pairs per file")
            .arg(
                Arg::new("fasta-file")
                    .short('f')
                    .aliases(["fasta"])
                    .required(true)
                    .help("A path to a valid fasta file.")
            )
            .arg(
                Arg::new("output-directory")
                    .short('o')
                    .aliases(["out"])
                    .required(false)
                    .default_value("./")
                    .help("The output directory that files will be placed in")
            )
            .arg(
                Arg::new("count")
                    .short('c')
                    .long("file-count")
                    .aliases(["count"])
                    .value_parser(clap::value_parser!(u16))
                    .help("How many sequences per file")
            )
    )
    .subcommand(
        Command::new("splitbysize")
            .about("Subcommand for splitting fasta files by user given size (in MegaBytes) into n (fasta_size / user_given_size) files")
            .arg(
                Arg::new("fasta-file")
                    .short('f')
                    .aliases(["fasta"])
                    .required(true)
                    .help("A path to a valid fasta file.")
            )
            .arg(
                Arg::new("mem-size")
                    .short('s')
                    .long("mem-size")
                    .required(true)
                    .value_parser(clap::value_parser!(u16))
                    .help("Size in MB that a fasta file is to be chunked into")
            )
            .arg(
                Arg::new("output-directory")
                    .short('o')
                    .aliases(["out"])
                    .required(false)
                    .default_value("./")
                    .help("The output directory that files will be placed in")
            )
    )
    .subcommand(
        Command::new("mapheaders")
            .about("Subcommand for stripping out headers and replacing with a standardised automatic or user-given string, this also returns a dict of old:new headers")
            .arg(
                Arg::new("fasta-file")
                    .short('f')
                    .aliases(["fasta"])
                    .required(true)
                    .help("A path to a valid fasta file.")
            )
            .arg(
                Arg::new("output-directory")
                    .short('o')
                    .aliases(["out"])
                    .required(false)
                    .default_value("./")
                    .help("The output directory which will contain the mapped-heads.txt as well as the *mapped.fasta")
            )
            .arg(
                Arg::new("replace-with")
                    .short('r')
                    .aliases(["replacement"])
                    .required(false)
                    .default_value("FMMH")
                    .help("The new header format, appended with a numerical value. Without being set the new header will default to 'FMMH_{numberical}'")
            )
    )
    .subcommand(
        Command::new("remapheaders")
            .about("Subcommand for stripping out previously mapped headers and replacing with the old headers")
            .arg(
                Arg::new("fasta-file")
                    .short('f')
                    .aliases(["fasta"])
                    .required(true)
                    .help("A path to a valid fasta file.")
            )
            .arg(
                Arg::new("output-directory")
                    .short('o')
                    .aliases(["out"])
                    .required(false)
                    .default_value("./new")
                    .help("The output directory which will contain the mapped-heads.txt as well as the *mapped.fasta")
            )
            .arg(
                Arg::new("map-file")
                    .short('m')
                    .aliases(["mapped-header-file"])
                    .required(true)
                    .help("The original mapped header field, a TSV of old-header, new-header")
            )
    )
    .subcommand(
        Command::new("profileONGOING")
        .about("Profile an input fasta file and return various statistics")
        .arg(
            Arg::new("fasta-file")
                .short('f')
                .aliases(["fsata"])
                .required(true)
                .help("The input fasta file for profiling")
        )
    )
    .subcommand(
        Command::new("agp-to-fasta")
        .about("Convert an agp file and original fasta file into a fasta file - useful for curation")
        .arg(
            Arg::new("original-fasta-file")
                .short('f')
                .aliases(["original-fasta"])
                .required(true)
                .help("The input fasta file for re-organising")
        )
        .arg(
            Arg::new("agp")
                .short('a')
                .aliases(["agp file"])
                .required(true)
                .help("The AGP file used to re-organise the input fasta")
        )
        .arg(
            Arg::new("sort")
                .short('s')
                .required(false)
                .value_parser(clap::value_parser!(u16))
                .default_value("false")
                .help("Size sort the output or leave as order in AGP")
        )
        .arg(
            Arg::new("output")
                .short('o')
                .aliases(["out"])
                .required(false)
                .default_value("./new.fasta")
                .help("The output name of the new fasta file")
        )
    )
    .subcommand(
        Command::new("subsetONGOING")
        .about("Subset a fasta file in a random manner by percentage of file")
        .arg(
            Arg::new("fasta-file")
                .short('f')
                .aliases(["fsata"])
                .required(true)
                .help("The input fasta file for profiling")
        )
        .arg(
            Arg::new("random")
                .short('r')
                .value_parser(clap::value_parser!(bool))
                .default_value("false")
                .aliases(["random"])
                .help("Random subset of input file. Default skims the first X given percent")
        )
        .arg(
            Arg::new("percent")
                .short('p')
                .value_parser(clap::value_parser!(u16))
                .default_value("50")
                .aliases(["proportion"])
                .required(true)
                .help("Percentage of the original file entries that should be retained")
        )
    )
    .get_matches();

    println! {
        "{}\n{}\n{}",
        "WELLCOME TO TreeVal Data Prepper".bold().purple(),
        "This has been made to help prep data for use in the Treeval and curationpretext pipelines",
        "ONLY THE yamlvalidator IS SPECIFIC TO TREEVAL, THE OTHER COMMANDS CAN BE USED FOR ANY OTHER PURPOSE YOU WANT".purple()
    };

    println!("OPERATING SYSTEM: {}", env::consts::OS.purple()); // Prints the current OS.

    let mut path_sep = "/";
    match env::consts::OS {
        "windows" => {
            path_sep = "\\";
            println!("Changing path separators, because windows...")
        }
        "macos" => println!("Supported:  macos is basically linux"),
        "linux" => println!("Supported: linux is Linux!"),
        _ => (),
    };

    println!(
        "RUNNING : {:?} : SUBCOMMAND",
        match_result.subcommand_name().unwrap()
    );

    match match_result.subcommand_name() {
        Some("splitbycount") => {
            let arguments = match_result.subcommand_matches("splitbycount");
            _ = split_file_by_count(arguments, path_sep);
        }
        Some("splitbysize") => {
            let arguments: Option<&clap::ArgMatches> =
                match_result.subcommand_matches("splitbysize");
            _ = split_file_by_size(arguments, path_sep);
        }
        Some("mapheaders") => {
            let arguments: Option<&clap::ArgMatches> =
                match_result.subcommand_matches("mapheaders");
            _ = map_fasta_head(arguments);
        }
        Some("validateyaml") => {
            let arguments = match_result.subcommand_matches("validateyaml");
            _ = validate_yaml(arguments, path_sep);
        }
        Some("remapheaders") => {
            let arguments: Option<&clap::ArgMatches> =
                match_result.subcommand_matches("remapheaders");
            _ = remapping_head(arguments);
        }
        _ => {
            unreachable!()
        }
    };
    Ok(())
}
